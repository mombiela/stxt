Document (dev.stxt.namespace):STXT-SPEC-DRAFT

	Metadata:
		Author: Joan Costa Mombiela
		Last modif: 2025-12-05
		
	Header: STXT-SPEC-DRAFT
	
	Alert >>
		**Página en construcción.**\\
		El contenido se muestra sólo como ejemplo del progreso actual,
		y puede cambiar notablemente con la versión definitiva. 
		
	Content>>
	
		**STXT (Semantic Text) — Core Language Specification**\\
		**Category:** Standards Track\\
		**Status:** Draft\\
		**Format:** Markdown (RFC-style)
		
	Subheader: 1. Introducción
	
	Content >>
		Este documento define la especificación del lenguaje **STXT (Semantic Text)**.
		
		STXT es un lenguaje **Human-First**, diseñado para que su forma natural sea legible, 
		clara y cómoda para las personas, manteniendo al mismo tiempo una estructura precisa 
		y fácilmente procesable por máquinas.
		
		STXT es un formato textual jerárquico y semántico orientado a:
		
		* Representar documentos y datos de manera clara.
		* Ser extremadamente sencillo de leer y escribir.
		* Ser trivial de parsear en cualquier lenguaje.
		* Permitir tanto contenido estructurado como texto libre.
		* Extender su semántica mediante `@stxt.schema`.
		
		Este documento describe la **sintaxis base** del lenguaje.

	Subheader: 2. Terminología

	Content >>
		Las palabras clave **"DEBE"**, **"NO DEBE"**, **"DEBERÍA"**, **"NO DEBERÍA"**, y **"PUEDE"** deben interpretarse según **RFC 2119**.
		
	Subheader: 3. Codificación del Documento

	Content >>
		Un documento STXT **DEBERÍA** codificarse en **UTF-8 sin BOM**.
		
		Un parser:
		
		* **PUEDE** aceptar documentos que comiencen con BOM.
		* **DEBERÍA** emitir una advertencia si aparece.
		
	Subheader: 4. Unidad Sintáctica: Nodo
		
	Content >>
		Cada línea no vacía del documento que no sea comentario ni parte de un bloque `>>` define un **nodo**.
		
		Existen dos formas de nodo:
		
		1. **Nodo simple o contenedor**: `Nombre: Valor del Nodo`
		2. **Nodo de bloque textual (`>>`)**: `Nombre >>`
		
		Un nodo puede incluir opcionalmente un namespace:
		
	Code>>
		Nombre (namespace.normal):
		Nombre (@namespace.especial) >>
		
	Subsubheader: 4.1 Normalización del nombre del nodo
		
	Content >>
		El nombre del nodo se toma a partir del texto comprendido entre:
		
		- El primer carácter no perteneciente a la indentación, y
		- El primer carácter que pertenezca a cualquiera de:
		  - El inicio de un namespace `(`,
		  - El carácter `:`,
		  - El operador `>>`,
		  - O el fin de línea.
		
		Sobre ese fragmento se aplica:
		
		- Eliminación de espacios y tabuladores iniciales y finales (trim).
		- Compactación de espacios en uno sólo
		
		El resultado de esta normalización es el **nombre del nodo**.
		
		Un nodo cuyo nombre lógico sea la cadena vacía (`""`) es inválido y **DEBE** provocar un error de parseo.
		
		Ejemplos equivalentes a nivel de `Nombre de nodo`:

	Code>>
		Nombre de nodo: valor
		Nombre  de   nodo   : valor
		Nombre  de nodo (@ns):
		Nombre de nodo(@ns):
		Nombre  de nodo >>
		Nombre de nodo>>
		
	Subsubheader: 4.2 Restricciones del nombre del nodo
		
	Content >>
		El nombre del nodo sólo permitirá carácteres alfanuméricos y los carácteres `-`, `_`, ` `.
		Se permiten nombres con diacríticos, mayúsculas y minúsculas.		
		
	Subsubheader: 4.3 Nombre canónico del nodo
		
	Content >>
		El nombre canónico se forma a partir del nombre del nodo mediante el siguiente proceso:
		
		* Descomposición Unicodo (NFKD)
		* Convierte a minúsculas
		* Elimina diacríticos
		* Compacta espacios (no necesario sobre nombre ya normalizado)
		* Reemplaza [^a-z0-9] por `-`. No se permiten 2 o más guiones seguidos, se deben compactar a uno sólo (`-`) 
		* Elimina guiones (`-`) al inicio y al final si existieran
		
		El nombre canónico será usado para saber si un nodo tiene el mismo nombre que otro.
		También será usado internamente por todas las operaciones de búsqueda o comprobación,
		para saber si se trata del mismo elemento.
		
		Ejemplos de transformación:
		
	Code >>
		Un nombré con äcento: un-nombre-con-acento
		UN NOMBRE con äcento: un-nombre-con-acento
		TAMaÑo número 2__ y 3: tamano-numero-2-y-3

	Subsubheader: 4.4 Normas de estilo
	Content >>
		La normas de estilo son las siguientes:
		
		* Separar el nombre de la definición de un namespace con un sólo espacio
		* Separar `:` del valor con un sólo espacio
		* `:` va inmediatamente después del nombre o del namespace si lo hubiera
		* `>>` no tiene ningún carácter después
		* No se usa más de un espacio en los nombres
		* Namespace sin espacios en la definición `(namespace.def)`
		
		Ejemplos de estilo correcto:
		
	Code>>
		Nombre con valor: El valor
		Nombre sin valor:
		Nombre con namespace (el.namespace):
		Nodo de texto >>
		
	Subheader: 5. Nodos con `:` (nodos contenedor, permiten valor)
		
	Content >>
		La forma con `:` define un nodo que:
		
		* Puede tener valor (opcional).
		* Puede no tener valor (nodo vacío).
		* Puede tener hijos (nodos anidados).
		* Su contenido estructurado incluye:
		  * La propia línea del nodo.
		  * Sus descendientes con mayor indentación
		
		Ejemplos:
		
	Code >>
		Titulo: Informe
		Autor: Joan
		Nodo:
		Nodo: Valor
		Nodo:
		    SubNodo 1: 123
		    Otro subnodo: 456

	Subheader: 6. Nodos con `>>` (bloque textual)
		
	Content >>
		La forma con `>>` define un bloque de **texto literal**.
		
		Ejemplos válidos:

	Code >>		
		Descripcion >>
		    Línea 1
		    Línea 2

	Code >>	
		Seccion>>
		    Acepta el operador sin espacio
		
	Subsubheader: 6.1 Reglas formales
		
	Content >>
		* La línea del nodo `>>` **NO DEBE** contener contenido significativo tras `>>`, excepto espacios opcionales.
		* Todas las líneas con indentación **estrictamente mayor** que la del nodo `>>` pertenecen al **contenido textual del bloque**.
		* Dentro del bloque:
		  * El parser **NO DEBE** interpretar ninguna línea como nodo estructurado, aunque contenga `:` u otra sintaxis de STXT.
		  * El parser **NO DEBE** interpretar líneas que comienzan por `#` como comentarios; todas las líneas son texto literal.
		* El bloque termina cuando aparece una **línea no vacía** cuya indentación es **menor o igual** que la indentación del nodo `>>`.
		* Las líneas vacías **dentro del bloque** se conservan tal cual y **NO DEBE** cerrar el bloque, independientemente de su indentación.
		
	Subsubheader: 6.2 Ejemplo
		
	Code >>
		Bloque >>
		    Texto
		        Hijo: valor SI permitido, es texto, no se parsea
		        Otro hijo: SI permitido
		    # Esto también es texto
		SiguienteNodo: valor

	Content >>		
		En este ejemplo:
		
		* Todo lo indentado por debajo de `Bloque >>` es texto literal.
		* `Hijo: valor` y `Otro hijo: SI permitido` **no** son nodos, sino texto.
		* `SiguienteNodo: valor` está fuera del bloque `>>`.
		
	Subheader: 7. Namespaces
		
	Content >>
		Un namespace es opcional y se especifica así:

	Code >>		
		Nodo (@com.example.docs):
		
	Content >>
		Reglas:
		
		* Un namespace **PUEDE** empezar por `@`.
		* **DEBE** usar formato jerárquico (`a.b.c`).
		* Se hereda por los nodos hijos.
		* El namespace por defecto es **``**.
		* Un nodo hijo puede redefinir su namespace indicando (otro.namespace), en cuyo caso usa ese namespace en lugar del heredado.
		
	Subheader: 8. Indentación y Jerarquía
		
	Content >>
		La indentación define la jerarquía estructurada del documento.
		
	Subsubheader: 8.1 Indentación Permitida
		
	Content >>
		Un documento STXT:
		
		* **PUEDE** usar únicamente espacios o únicamente tabuladores.
		* **NO DEBERÍA** mezclarlos en una misma línea. 
		  En caso de mezclarlos, los espacios que no lleguen a 4 se descartan si aparece un tabulador
		* Si usa espacios:
		  * **DEBE** usar exactamente **4 espacios** por nivel.
		* Si usa tabs:
		  * Cada tab representa exactamente 1 nivel.
		
	Subsubheader: 8.2 Jerarquía
		
	Content >>
		* La indentación **DEBE** aumentar de forma consecutiva (no se permiten saltos).
		* Los nodos hijos **DEBE** tener mayor indentación que su padre.
		* La indentación dentro de un bloque `>>` **no afecta a la jerarquía estructural**: es simplemente texto.
		
	Subheader: 9. Comentarios
		
	Content >>
		Fuera de bloques `>>`, una línea es un comentario si, tras su indentación, el primer carácter es `#`.
		
		Ejemplo:
	Code >>		
		# Comentario raíz
		Nodo:
		    # Comentario interior
		
	Subsubheader: 9.1 Comentarios dentro de bloques `>>`
		
	Content >>
		Dentro de un bloque `>>`:
		
		* Toda línea con indentación igual o superior a la indentación mínima del contenido del 
		  bloque **DEBE** tratarse como texto literal, incluso si empieza por `#`.
		* Una línea menos indentada que el bloque termina el bloque y puede ser:
		
		  * Un comentario, si empieza por `#`.
		  * Un nodo estructurado.
		
		Ejemplo:
	Code >>
		Documento:
		    Texto >>
		        # Esto es texto
		        Línea normal
		            # También es texto
		    # Esto sí es comentario

	Subheader: 10. Normalización de espacios en blanco
		
	Content >>
		Esta sección define cómo deben normalizarse los espacios en blanco para 
		garantizar que distintas implementaciones produzcan la misma representación 
		lógica a partir del mismo texto STXT.
		
	Subsubheader: 10.1 Valores inline (`:`)
		
	Content >>
		Al parsear un nodo con `:`:
		
		1. El parser toma todos los caracteres desde inmediatamente después de `:` hasta el fin de línea.
		2. El valor inline **DEBE** normalizarse aplicando:
		
		   * Eliminación de espacios y tabuladores iniciales (trim a la izquierda).
		   * Eliminación de espacios y tabuladores finales (trim a la derecha).
		
		Esto implica que las siguientes líneas son equivalentes a nivel de parseo:
		
	Code >>
		Nombre: Joan
		Nombre:     Joan
		Nombre: Joan    
		Nombre:     Joan    

	Content >>		
		En todos los casos, el valor lógico del nodo `Nombre` es `"Joan"`.
		
		Si tras el `trim` el valor queda vacío, el valor inline se considera la cadena vacía (`""`).
		
	Subsubheader: 10.2 Líneas dentro de bloques `>>`
		
	Content >>
		Para cada línea que pertenece a un bloque `>>`:
		
		1. El parser determina el contenido de la línea a partir del texto que sigue a la indentación mínima del bloque (es decir, elimina solo la indentación de bloque, pero conserva cualquier indentación adicional como parte del texto).
		2. Sobre ese contenido, el parser **DEBE** eliminar todos los espacios y tabuladores finales (trim a la derecha).
		
		Ejemplo de canonicalización de líneas:
		
	Code >>
		Bloque >>
		    Hola    
		        Mundo        

	Content >>		
		Representación lógica del contenido del bloque:
		
		* Línea 1: `"Hola"`
		* Línea 2: `"    Mundo"`  (las 4 espacios adicionales tras la indentación mínima se conservan, los espacios del final se eliminan)
		
	Subsubheader: 10.3 Líneas vacías en bloques `>>`
		
	Content >>
		* Las líneas vacías **intermedias** dentro del bloque (es decir, entre líneas no vacías) **DEBE** preservarse como líneas vacías (`""`) en la representación lógica del texto.
		* Tras leer todas las líneas de un bloque `>>`, las implementaciones **DEBE** eliminar las líneas vacías consecutivas al final del bloque (si las hubiera).
		
		En otras palabras:
		
		* Las líneas en blanco **no cierran** el bloque.
		* No se conservan “saltos de línea sueltos” al final del bloque a nivel lógico.
		
		Ejemplo:
		
	Code >>
		Texto >>
		    Línea 1
		    
		    Línea 2
		    
	Content >>		
		Contenido lógico del bloque:
		
		* Línea 1: `"Línea 1"`
		* Línea 2: `""`
		* Línea 3: `"Línea 2"`
		
		Las líneas vacías finales después de `"Línea 2"` se eliminan en la representación lógica.
		
	Subsubheader: 10.4 Normalización del nombre del nodo
		
	Content >>
		La normalización del nombre del nodo ya se define formalmente en la **sección 4.1**.
		Como recordatorio operativo:
		
		* Antes de interpretar `:` o `>>`, el parser **DEBE** obtener el nombre lógico aplicando la normalización descrita en 4.2.
		* Esto implica eliminar espacios y tabuladores a izquierda y derecha del fragmento que constituye el nombre.
		* Distintas variantes con espacios siguen produciendo el mismo nombre lógico.
		
		Ejemplo recordatorio:
		
	Code >>
		Nombre: valor
		Nombre : valor
		Nombre    :   valor

	content >>
		En los tres casos, el nombre lógico del nodo es `"Nombre"`.
		
	Subheader: 11. Reglas de Error
		
	Content >>
		Un documento es inválido si ocurre alguna de estas condiciones:
		
		1. Mezcla de espacios y tabuladores.
		2. Espacios que no sean múltiplos de 4 (cuando se usan espacios para indentación).
		3. Saltos en los niveles de indentación.
		4. Un nodo `>>` contiene contenido significativo inline en la misma línea que `>>`.
		5. Un nodo no contiene ni `:` ni `>>`.
		6. Un namespace no empieza por `@`.
		7. Se usa `:` y `>>` en la misma línea.
		
		Un parser conforme **DEBE** rechazar el documento.
		
	Subheader: 12. Conformidad
		
	Content >>
		Una implementación STXT es conforme si:
		
		* Implementa la sintaxis descrita en este documento.
		* Aplica las reglas estrictas de indentación y jerarquía.
		* Interpreta correctamente nodos con `:` y bloques `>>`.
		* Interpreta comentarios fuera de bloques `>>`.
		* Trata **todo** lo dentro de bloques `>>` como texto literal.
		* Aplica las reglas de normalización de espacios en blanco de la sección 10.
		* Rechaza documentos inválidos según la sección 11.
		
	Subheader: 13. Extensión de Archivo y Media Type
		
	Subsubheader: 13.1 Extensión de Archivo
		
	Content >>
		Los documentos STXT **DEBERÍAN** usar la extensión: `.stxt`
		
	Subsubheader: 13.2 Media Type (MIME)
		
	Content >>
		* Media type oficial: `text/stxt`
		* Alternativa compatible: `text/plain`

	Subheader: 14. Ejemplos Normativos
		
	Subsubheader: 14.1 Documento válido
		
	Code >>
		Documento (@com.example.docs):
		    Autor: Joan
		    Fecha: 03/12/2025
		    Resumen >>
		        Este es un bloque de texto.
		        Con varias líneas.
		    Config:
		        Modo: Activo
		
	Subsubheader: 14.2 Bloque con líneas vacías
		
	Code >>
		Texto>>
		    
		    Línea 2
	Content >>		
		Contenido lógico del bloque:
		
		1. `""`
		2. `"Línea 2"`

	
	Subsubheader: 14.3 Comentarios dentro y fuera de bloques
		
	Code >>
		Documento:
		    Cuerpo >>
		        # Esto es texto
		        Más texto
		    # Esto sí es comentario
		
	Subsubheader: 14.4 Bloque con “pseudo-hijos” (válido)
		
	Code >>
		Bloque >>
		    Texto
		        Hijo: valor SI permitido
		        Otro hijo: SI permitido
		    # Esto también es texto
		Siguiente: Nodo
		
	Subsubheader: 14.5 Inválido: mezcla de indentación
		
	Code >>
		A:
		    B:
		\t\tC: valor
		
	Subheader: 15. Apéndice A — Gramática (Informal)
		
	Code >>
		Nodo             = Indent Nombre NamespaceOpt (InlineOpt | BlockOpt)
		NamespaceOpt     = "(" "@" Ident ")" 
		InlineOpt        = ":" Esp? TextoInline?
		BlockOpt         = Esp? ">>"
		
		TextoInline      = cualquier contenido hasta el fin de línea
		BloqueTexto      = líneas indentadas (texto literal, no estructurado)
		
		Comentario       = Indent "#" Texto       ; Solo fuera de bloques '>>'
		
		# Regla esencial:
		#  - Dentro de un bloque '>>', cualquier línea con indentación >= la
		#    indentación mínima del bloque es texto.
		#  - Las líneas vacías nunca cierran el bloque.
		#  - Una línea no vacía con indentación <= la del nodo '>>' lo cierra.
		
		Indent           = ("    ")* | ("\t")*

	Subheader: 16. Apéndice B — Interacción con `@stxt.schema`
		
	Content >>
		El sistema de schemas permite añadir validación semántica a documentos STXT **sin modificar la sintaxis base** del lenguaje.
		
		El núcleo STXT no define cómo debe reaccionar una implementación: el comportamiento pertenece exclusivamente al sistema de schemas (*STXT-SCHEMA-SPEC*).
		
		Un schema es un documento STXT cuyo namespace es: `@stxt.schema`
		
		y cuyo objetivo es definir las reglas estructurales, tipos de valor y cardinalidades de los nodos pertenecientes a un namespace concreto.
		
		El núcleo STXT **no interpreta** estas reglas; únicamente define cómo se expresan y cómo se combinan mediante namespaces.
		
	Subsubheader: 16.1. Asociación de un schema a un namespace
		
	Content >>
		Para asociar un schema al namespace `com.example.docs`, se escribe un documento:
		
	Code>>
		Schema (@stxt.schema): com.example.docs
			Node: Email
				Children:
					Child: From
					Child: To
					Child: Cc
					Child: Bcc
					Child: Title
						Max: 1
					Child: Body Content
						Min: 1
						Max: 1
					Child: Metadata (com.google)
						Max: 1
			Node: From
			Node: To
			Node: Cc
			Node: Bcc
			Node: Title
			Node: Body Content
				Type: TEXT
		
	Subsubheader: 16.2. Aplicación a documentos STXT
		
	Content >>
		Un documento que declare el mismo namespace:
		
	Code >>
		Documento (@com.example.docs):
		    Campo1: valor
		    Texto: uno
		    Texto: dos
	
	Content >>
		
		puede ser validado por una implementación que soporte schemas STXT:
		
		* Validando la presencia de nodos según `Node` del schema.
		* Validando tipos de valor (`TEXT`, `DATE`, `NUMBER`, etc.).
		* Validando cardinalidades definidas en `Child`.
		
	Subheader: 16.3. Independencia del núcleo
		
	Content >>
		STXT **NO DEBE** imponer reglas semánticas provenientes de schemas.
		El sistema de schemas es un componente separado y opcional que opera **sobre** el STXT ya parseado.
		
		También **PUEDE** actuar como parte del proceso de parseo. En ese caso **DEBERÍA** estar débilmente acoplado con él. 
		Esto permitiría detectar errores sin tener que esperar al final del parseo de parseo.
		
	Subheader: 17. Apéndice B — Interacción con `@stxt.template`

	Content>>	
		El sistema de templates permite añadir validación semántica a documentos STXT **sin modificar la sintaxis base** del lenguaje.
		
		El núcleo STXT no define cómo debe reaccionar una implementación: el comportamiento pertenece exclusivamente al sistema de templates (*STXT-TEMPLATE-SPEC*).
		
		Un template es un documento STXT cuyo namespace es: `@stxt.template`
		
		y cuyo objetivo es definir las reglas estructurales, tipos de valor y cardinalidades de los nodos pertenecientes a un namespace concreto.
		
		El sistema de Templates es análogo a los schemas, pero con una syntaxis simplificada, orientada a prototipos rápidos. 
		Aún así, es un sistema perfectamente válido para todo tipo de documentos.
		
		El sistema de templates **PUEDE** convivir junto a un sistema con esquemas, ya que al final un Template define la misma información que un schema.
	
	Subsubheader: 17.1. Asociación de un schema a un template
		
	Content >>
		Para asociar un schema al namespace `com.example.docs` con templates, se escribe un documento:
		
	Code>>
		Template (@stxt.template): com.example.docs
			Structure >>
				Email:
					From:
					To:
					Cc:
					Bcc:
					Title: (?)
					Body    Content: (1) TEXT
					Metadata (com.google): (?)
					
	Content>>
		Una vez declarado, los templates cumplen la misma función que los schemas.
		Un validador estándar **DEBERÍA** priorizar un schema por encima de un template.  
	
	Subheader: 18. Fin del Documento
			
				
