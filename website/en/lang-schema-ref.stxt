Document (dev.stxt.namespace):STXT-SCHEMA-SPEC-DRAFT

	Metadata:
		Author: Joan Costa Mombiela
		Last modif: 2025-12-05
		
	Header: STXT-SCHEMA-SPEC-DRAFT
	
	Alert >>
		**Page under construction.**\\
		The content is shown only as an example of current progress,
		and may change significantly with the final version. 
		
	Content>>
		**STXT (Semantic Text) — Schema Language Specification**\\
		**Category:** Standards Track\\
		**Status:** Draft\\
		**Format:** Markdown (RFC-style)
		
	Subheader: 1. Introduction
	Content >>		
		This document defines the specification of the **STXT Schema** language, a mechanism to validate STXT documents through formal semantic rules.
		
		A **schema**:
		
		* Is an STXT document with namespace `@stxt.schema`.
		* Defines the nodes, types, and cardinalities of the target namespace.
		* Does not modify the base STXT syntax; it operates on the already-parsed structure.
		
	Subheader: 2. Terminology
		
	Content >>
		The key words **"MUST"**, **"MUST NOT"**, **"SHOULD"**, **"SHOULD NOT"**, and **"MAY"** are to be interpreted as described in **RFC 2119**.
		
		Terms such as *node*, *indentation*, *namespace*, *inline* and *block `>>`* retain their meaning in *STXT-SPEC*.
		
	Subheader: 3. Relationship between STXT and Schema
		
	Content >>
		Schema-based validation occurs **after** STXT parsing:
		
		1. Parsing into an STXT hierarchical structure.
		2. Resolution of the logical namespace (inheritance).
		3. Application of the corresponding schema.
		
	Subheader: 4. General structure of a Schema
		
	Content >>
		A schema is a document whose root node is: `Schema (@stxt.schema): <target_namespace>`
		
		Example:

	Code >>
		Schema (@stxt.schema): com.example.docs
		    Description: Schema for example documents
		    Node: Document
		        Type: EMPTY
		        Childs>>
		            (?) Metadata (@com.google.html)
		            (*) Autor
		            (?) Fecha
		            (1) Content
		    Node: Autor
		        Type: TEXT INLINE
		    Node: Fecha
		        Type: DATE
		    Node: Content
		        Type: TEXT MULTILINE

	Subheader: 5. One schema per namespace
		
	Content >>
		For each logical namespace:
		
		* **MUST NOT** exist more than one active schema simultaneously.
		* Loading two schemas for the same namespace ⇒ **configuration error**.
		
	Subheader: 6. Node Definitions (`Node:`)
		
	Subsubheader:  6.1 Basic form
		
	Code >>
		Node: NombreNodo
		    Type: Tipo
		    Childs>>
		        (<card>) NombreHijo [(@namespace)]
	Content >>
		Rules:
		
		* `NombreNodo` **MUST** be unique within the schema.
		* Each `Node` defines the semantics of the node in the target namespace.
		* If `Type` is omitted ⇒ default type `TEXT INLINE`.
		
	Subheader: 7. Children (`Childs>>`) and cross-namespaces
		
	Content >>
		Each `Childs>>` entry:
		
		```text
		(<card>) NombreHijo [(@namespace)]
		```
		
		Where:
		
		* `(<card>)` = cardinality (see section 8).
		* `NombreHijo` = logical name of the child node.
		* `(@namespace)` (optional):
		
		  * If omitted: the schema’s target namespace is assumed.
		  * If specified: the child belongs to that specific namespace.
		
	Subsubheader: 7.1. NEW RULE (strict and mandatory)
		
	Content >>
		**Every node that appears in `Childs>>` must have its own definition as `Node:` in its corresponding schema.**
		
		This implies:
		
		* If it appears:
		
		  ```stxt
		  (1) Metadata (@com.google.html)
		  ```
		
		  then **a schema for `com.google.html` must exist**
		  **and within it `Node: Metadata` must exist**.
		
		* This rule is mandatory both in *strict* mode and in non-strict mode.
		
		This way we avoid “ghost” children and ensure that all nodes have defined semantics.
		
		---
		
	Subheader: 8. Cardinalities
		
	Content >>
		Allowed forms:
		
		| Form     | Meaning                    |
		| -------- | -------------------------- |
		| `num`     | Exactly `num`.            |
		| `*`       | Any number (`0..∞`).      |
		| `+`       | One or more (`1..∞`).     |
		| `?`       | Zero or one (`0..1`).     |
		| `num+`    | `num` or more.            |
		| `num-`    | `0..num`.                 |
		| `min,max` | Between `min` and `max`.  |
		
		Rules:
		
		* Applies per instance of the parent node.
		* Counts only **direct** children with name + effective namespace.
		* A conforming validator **MUST** check cardinalities.
		
		---
		
	Subheader: 9. Types
		
	Content >>
		Types define:
		
		1. **The form of the node value** (inline, `>>` block, or none).
		2. **Whether the node can have children**.
		3. **Content validation**.
		
	Subsubheader: 9.1. Official type table
		
	Content >>
		| Type             | Allowed value forms        | Children allowed | Description / Validation                                               |
		|------------------|----------------------------|------------------|------------------------------------------------------------------------|
		| TEXT INLINE      | INLINE                     | YES              | Inline text. **Default type.**                                         |
		| TEXT MULTILINE   | BLOCK                      | NO               | Only `>>` block.                                                       |
		| TEXT             | INLINE or BLOCK            | NO               | Generic text. Can be inline or `>>` block, but never has children.     |
		| BOOLEAN          | INLINE                     | YES              | `true` / `false`.                                                      |
		| NUMBER           | INLINE                     | YES              | JSON number.                                                           |
		| DATE             | INLINE                     | YES              | `YYYY-MM-DD`.                                                          |
		| TIMESTAMP        | INLINE                     | YES              | ISO 8601.                                                              |
		| EMAIL            | INLINE                     | YES              | Valid email.                                                           |
		| URL              | INLINE                     | YES              | Valid URL.                                                             |
		| UUID             | INLINE                     | YES              | Standard UUID.                                                         |
		| HEXADECIMAL      | INLINE                     | YES              | `[0-9A-Fa-f]+`.                                                        |
		| BINARY           | INLINE                     | YES              | Binary string.                                                         |
		| BASE64           | BLOCK                      | NO               | Base64 block.                                                          |
		| CODE[language]   | BLOCK                      | NO               | Code in `<language>`.                                                  |
		| EMPTY            | NONE                       | YES              | Structural node with no value.                                         |
		
	Subsubheader: 9.2. Key rules
		
	Content >>
		* The type **does NOT control requiredness**, only the form and validity of the value.
		  Requiredness of appearance is controlled via cardinality.
		* **BLOCK-only** types (`TEXT MULTILINE`, `CODE:*`, `BASE64`)
		  ⇒ **MUST NOT** have children.
		* `EMPTY`:
		
		  * No inline value nor block.
		  * Children according to `Childs>>` are allowed.
		
		---
		
	Subheader: 10. Validator modes: *strict* and *non-strict*
		
	Subsubheader: 10.1. *Strict* mode (equivalent to “closed mode”) — **default**
		
	Content >>
		An STXT Schema validator in *strict* mode:
		
		* **MUST** require a schema for each namespace found.
		* **MUST** reject nodes that are not defined in their schema.
		* **MUST** validate:
		
		  * Allowed forms (`:`, `>>`, none).
		  * Value types.
		  * Cardinalities.
		  * Type/children compatibility.
		  * Knowledge of schema for all referenced namespaces.
		* **MUST** apply the rule in section 7.1:
		  **if a child appears in `Childs>>`, its definition must exist in its schema.**
		
	Subsubheader: 10.2. *Non-strict* mode (configurable open mode)
		
	Content >>
		A validator **MAY** offer a non-strict mode:
		
		* If a namespace has no schema:
		
		  * It may accept the document but **SHOULD** emit a warning.
		* If a `Node` is not defined:
		
		  * It may be accepted with a warning.
		* Children not contemplated in `Childs>>`:
		
		  * They are accepted but marked as "not covered by the schema".
		
		**Important:**
		Even in *non-strict* mode, rule **7.1** remains:
		
		> If a child appears in `Childs>>` of a schema, that child **MUST** be defined in its corresponding schema.
		
	Subheader: 11. Normative Examples
		
	Subsubheader: 11.1. Schema with cross-namespace references
		
	Content >>
		```stxt
		Schema (@stxt.schema): com.example.docs
		    Node: Document
		        Type: EMPTY
		        Childs>>
		            (?) Metadata (@com.google.html)
		            (1) Content
		    Node: Content
		        Type: TEXT MULTILINE
		```
		
		And in `com.google.html`:
		
		```stxt
		Schema (@stxt.schema): com.google.html
		    Node: Metadata
		        Type: TEXT INLINE
		```
		
	Subsubheader: 11.2. Valid document
		
	Content >>
		```stxt
		Document (@com.example.docs):
		    Metadata (@com.google.html): info
		    Content>>
		        Line 1
		        Line 2
		```
		
		---
		
	Subheader: 12. Schema Errors
		
	Content >>
		A schema is invalid if:
		
		1. It defines two `Node` with the same name.
		2. It uses an unknown `Type`.
		3. It uses forms (`:`, `>>`) incompatible with the type.
		4. It defines `Childs>>` in a `Node` whose type does not allow children.
		5. The cardinality is invalid.
		6. It references a non-existent namespace **without providing a schema for that namespace**.
		7. **A child appears in `Childs>>` whose `Node` is not defined in its corresponding schema**.
		
		---
		
	Subheader: 13. Conformance
		
	Content >>
		An implementation is conforming if:
		
		* It fully implements this document.
		* It validates types, value forms, and cardinalities.
		* It applies the strict rule of mandatory definition of all nodes referenced in `Childs>>`.
		* It correctly handles *strict* and *non-strict* modes.
		* It rejects invalid documents and schemas.
		
		---
		
	Subheader: 14. Schema of the Schema (`@stxt.schema`)
		
	Content >>
		This section defines the **official schema** of the schema system itself: the meta-schema that validates all documents in the `@stxt.schema` namespace.
		
		---
		
	Subsubheader: 14.1. Considerations
		
	Content >>
		* Every schema document is:
		
		  ```stxt
		  Schema (@stxt.schema): <target-namespace>
		  ```
		
		* A schema contains:
		
		  * Optionally a `Description`.
		  * Zero or more `Node` nodes.
		
		* Each `Node`:
		
		  * Has an inline value (the node name of the target namespace).
		  * May optionally have:
		
		    * `Type`
		    * `Childs`
		    * `Description`
		
		* The names (`Schema`, `Node`, `Type`, `Childs`, `Description`) belong to the `@stxt.schema` namespace.
		
		---
		
	Subsubheader: 14.2. Complete Meta-Schema
		
	Content >>
		```stxt
		Schema (@stxt.schema): stxt.schema
		    Description: Schema that defines the STXT Schema language
		
		    # Root node of the schema document
		    Node: Schema
		        Type: TEXT INLINE
		        Childs>>
		            (?)  Description
		            (*)  Node
		
		    # Defines a node of the target namespace
		    Node: Node
		        Type: TEXT INLINE
		        Childs>>
		            (?)  Type
		            (?)  Childs
		            (?)  Description
		
		    # Declared type for a Node (optional, default TEXT)
		    Node: Type
		        Type: TEXT INLINE
		
		    # List of allowed children (multiline block)
		    Node: Childs
		        Type: TEXT MULTILINE
		
		    # Optional description (general text, inline or block)
		    Node: Description
		        Type: TEXT
		```
		
		---
		
	Subsubheader: 14.3. Quick read
		
	Content >>
		* `Schema`
		  Inline value = target namespace (e.g. `com.example.docs`).
		  Children: `Description` (?), `Node` (*).
		
		* `Node`
		  Inline value = target node name (e.g. `Document`, `Autor`).
		  Optional children:
		
		  * `Type` ⇒ specific type (if missing ⇒ `TEXT INLINE`).
		  * `Childs` ⇒ literal `Childs>>` block.
		  * `Description` ⇒ explanatory text.
		
		* `Type`
		  Inline (`TEXT INLINE`), with the type name (`EMPTY`, `TEXT INLINE`, `NUMBER`, `CODE:json`, etc.).
		
		* `Childs`
		  `TEXT MULTILINE`: literally contains the `Childs>>` block.
		
		* `Description`
		  `TEXT`: can be inline or multiline.
		
		---
		
	Subsubheader: 14.4. Minimal valid example
		
	Content >>
		```stxt
		Schema (@stxt.schema): com.example.docs
		    Node: Document
		```
		
		`Document` is considered type `TEXT INLINE` (by default).
		
		---
		
	Subsubheader: 14.5. Complete example
		
	Content >>
		```stxt
		Schema (@stxt.schema): com.example.docs
		    Description: Example schema
		    Node: Document
		        Type: EMPTY
		        Childs>>
		            (1) Title
		            (*) Author
		            (?) Metadata (@com.google.html)
		    Node: Title
		        Type: TEXT INLINE
		    Node: Author
		        Type: TEXT INLINE
		```
		
	Subheader: 15. End of Document